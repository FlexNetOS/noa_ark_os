use std::path::Path;

use anyhow::Result;
use noa_core::config::manifest::KernelManifest;

/// Validate a kernel manifest file and return the parsed structure.
pub fn validate_kernel_manifest(manifest: &Path) -> Result<KernelManifest> {
    let manifest = KernelManifest::load_from_yaml(manifest)?;
    manifest.validate()?;
    Ok(manifest)
}

/// Ensure a portable bundle generated by tools/portable_builder.py looks complete.
pub fn verify_portable_bundle(bundle_dir: &Path, expected_formats: &[&str]) -> Result<()> {
    let bundle_path = bundle_dir.join("bundle.json");
    if !bundle_path.exists() {
        anyhow::bail!("bundle metadata not found at {}", bundle_path.display());
    }

    let lock_path = bundle_dir.join("bundle.lock");
    if !lock_path.exists() {
        anyhow::bail!("bundle lock not found at {}", lock_path.display());
    }

    let descriptor: serde_json::Value =
        serde_json::from_reader(std::fs::File::open(&bundle_path)?)?;
    let runtimes = descriptor
        .get("runtimes")
        .and_then(|value| value.as_array())
        .cloned()
        .unwrap_or_default();

    for runtime in runtimes {
        if let Some(name) = runtime.get("name").and_then(|value| value.as_str()) {
            let runtime_dir = bundle_dir.join("runtimes").join(name);
            if !runtime_dir.join("runtime.json").exists() {
                anyhow::bail!("runtime descriptor missing for {}", name);
            }
        }
    }

    for format in expected_formats {
        let descriptor = bundle_dir
            .join("targets")
            .join(format)
            .join("descriptor.json");
        if !descriptor.exists() {
            anyhow::bail!("target descriptor missing for format {}", format);
        }
    }

    Ok(())
}
