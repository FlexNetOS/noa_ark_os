# CRC Automation Pipeline
# Full automation: CRC → Validate → Build → Test → Deploy
# Triggered automatically when drops appear in ready/ queues

name: crc-auto-pipeline
version: 1.0.0

# Trigger configuration
triggers:
  - type: crc_ready_queue
    queues:
      - model-a-queue
      - model-b-queue
      - model-c-queue
      - model-d-queue
    conditions:
      confidence_min: 0.80

# Environment variables
env:
  RUST_LOG: info
  CARGO_TERM_COLOR: always
  CRC_PIPELINE_MODE: automated

# Pipeline stages
stages:
  # Stage 1: Validation
  - name: validation
    display_name: "Validate Code Quality"
    timeout_minutes: 10
    
    steps:
      - name: check_manifest
        display_name: "Check Drop Manifest"
        script: |
          echo "Validating drop manifest..."
          if [ -f "drop_manifest.json" ]; then
            echo "✓ Manifest found"
            cat drop_manifest.json
          else
            echo "✗ Manifest missing"
            exit 1
          fi
      
      - name: code_quality
        display_name: "Run Code Quality Checks"
        script: |
          echo "Running quality checks..."
          # Rust projects
          if [ -f "Cargo.toml" ]; then
            echo "Checking Rust code..."
            cargo fmt -- --check || echo "Warning: formatting issues"
            cargo clippy -- -D warnings || echo "Warning: clippy issues"
          fi
          echo "✓ Quality checks complete"
      
      - name: security_scan
        display_name: "Security Vulnerability Scan"
        script: |
          echo "Scanning for security vulnerabilities..."
          # cargo-audit for Rust
          if [ -f "Cargo.lock" ]; then
            cargo audit || echo "Warning: vulnerabilities found"
          fi
          echo "✓ Security scan complete"
  
  # Stage 2: Build
  - name: build
    display_name: "Build Artifacts"
    timeout_minutes: 30
    depends_on:
      - validation
    
    steps:
      - name: rust_build
        display_name: "Build Rust Project"
        condition: file_exists("Cargo.toml")
        script: |
          echo "Building Rust project..."
          cargo build --release
          echo "✓ Build succeeded"
      
      - name: javascript_build
        display_name: "Build JavaScript Project"
        condition: file_exists("package.json")
        script: |
          echo "Building JavaScript project..."
          npm install
          npm run build
          echo "✓ Build succeeded"
      
      - name: python_build
        display_name: "Build Python Project"
        condition: file_exists("setup.py")
        script: |
          echo "Building Python project..."
          pip install -e .
          echo "✓ Build succeeded"
      
      - name: collect_artifacts
        display_name: "Collect Build Artifacts"
        script: |
          echo "Collecting artifacts..."
          mkdir -p artifacts/
          
          # Rust artifacts
          if [ -d "target/release" ]; then
            find target/release -maxdepth 1 -type f -executable -exec cp {} artifacts/ \;
          fi
          
          # JavaScript artifacts
          if [ -d "dist" ]; then
            cp -r dist artifacts/
          fi
          
          echo "✓ Artifacts collected"
        artifacts:
          - artifacts/**/*
  
  # Stage 3: Test
  - name: test
    display_name: "Run Tests"
    timeout_minutes: 20
    depends_on:
      - build
    
    steps:
      - name: unit_tests
        display_name: "Run Unit Tests"
        script: |
          echo "Running unit tests..."
          
          # Rust tests
          if [ -f "Cargo.toml" ]; then
            cargo test --release
          fi
          
          # JavaScript tests
          if [ -f "package.json" ]; then
            npm test
          fi
          
          # Python tests
          if [ -f "pytest.ini" ] || [ -d "tests" ]; then
            pytest
          fi
          
          echo "✓ Unit tests passed"
      
      - name: integration_tests
        display_name: "Run Integration Tests"
        script: |
          echo "Running integration tests..."
          
          # Rust integration tests
          if [ -d "tests" ]; then
            cargo test --test '*' --release
          fi
          
          echo "✓ Integration tests passed"

  # Stage 4: CRC DAG execution
  - name: crc_dag
    display_name: "Execute CRC DAG Offline"
    timeout_minutes: 15
    depends_on:
      - test
    steps:
      - name: orchestrate_crc
        display_name: "Run CRC orchestrator"
        script: |
          echo "Running CRC orchestrator offline"
          cargo run -p noa_crc -- run --checkpoint out/ckpt
          cargo run -p noa_crc -- graph ls

  - name: single_host_acceptance
    display_name: "Single-host Acceptance"
    timeout_minutes: 15
    depends_on:
      - test

    steps:
      - name: verify_profile_manifest
        display_name: "Validate single_host profile"
        script: |
          echo "Checking single_host profile..."
          PROFILE=server/profiles/single_host/profile.toml
          if [ ! -f "$PROFILE" ]; then
            echo "single_host profile missing at $PROFILE"
            exit 1
          fi
          grep -q "single_host" "$PROFILE" || {
            echo "Profile does not contain single_host identifier"
            exit 1
          }
          echo "✓ Profile manifest present"

      - name: dry_run_bootstrap
        display_name: "Dry-run bootstrap script"
        script: |
          echo "Simulating single-host bootstrap"
          chmod +x services/single-host/init/noa-single-host.sh
          NOA_DRY_RUN=1 \
          NOA_PROFILE=server/profiles/single_host/profile.toml \
            services/single-host/init/noa-single-host.sh start all || true
          echo "✓ Bootstrap script executed"

      - name: profile_health_matrix
        display_name: "Profile capability health matrix"
        script: |
          set -e
          echo "Validating capability tokens for all profiles"
          for PROFILE in single_host air_gapped devcontainer edge_lite; do
            echo "→ Checking ${PROFILE}"
            NOA_PROFILE="server/profiles/${PROFILE}/profile.toml" \
              cargo test -p noa_core profile_switching --release -- --nocapture
          done
          echo "✓ Capability tokens validated across profiles"

      - name: coverage_report
        display_name: "Generate Coverage Report"
        continue_on_error: true
        script: |
          echo "Generating coverage report..."
          # Would use tarpaulin, codecov, etc.
          echo "✓ Coverage report generated"
  
  # Stage 4: Deploy (Model D Integration)
  - name: deploy
    display_name: "Deploy to Sandbox"
    timeout_minutes: 15
    depends_on:
      - test
    condition: >
      confidence >= 0.95 && 
      queue == 'model-d-queue'
    
    steps:
      - name: sandbox_deploy
        display_name: "Deploy to Model D Sandbox"
        script: |
          echo "Deploying to Model D sandbox..."
          echo "  Confidence: ${CONFIDENCE}"
          echo "  Source: ${SOURCE_TYPE}"
          
          # Copy to sandbox
          mkdir -p ../../sandboxes/model-d/
          cp -r . ../../sandboxes/model-d/${DROP_ID}/
          
          echo "✓ Deployed to sandbox"
      
      - name: integration_merge
        display_name: "Trigger Integration Merge"
        script: |
          echo "Triggering Model D integration merge..."
          # Would trigger merge from A+B+C → D
          echo "✓ Integration merge triggered"
  
  # Stage 5: Auto-Merge (High Confidence Only)
  - name: auto_merge
    display_name: "Auto-Merge to Main"
    timeout_minutes: 10
    depends_on:
      - deploy
    condition: >
      confidence >= 0.98 &&
      auto_approve == true
    
    steps:
      - name: create_pr
        display_name: "Create Pull Request"
        script: |
          echo "Creating pull request..."
          # Would use GitHub CLI or API
          echo "Title: [AUTO] CRC Drop ${DROP_ID}"
          echo "Body: Automated integration from CRC pipeline"
          echo "✓ PR created"
      
      - name: auto_approve
        display_name: "Auto-Approve and Merge"
        script: |
          echo "Auto-approving high-confidence drop..."
          echo "Confidence: ${CONFIDENCE}"
          # Would approve and merge PR
          echo "✓ Merged to main"
      
      - name: post_merge_cleanup
        display_name: "Post-Merge Cleanup"
        script: |
          echo "Cleaning up after merge..."
          # Archive original, clean ready queue
          echo "✓ Cleanup complete"

# Rollback strategy
rollback:
  enabled: true
  on_failure:
    - name: revert_merge
      condition: stage == 'auto_merge'
      script: |
        echo "Reverting failed auto-merge..."
        # Would revert Git commit
        echo "✓ Merge reverted"
    
    - name: move_to_failed
      script: |
        echo "Moving drop to failed queue..."
        mkdir -p ../../drop-in/failed/
        mv ${READY_PATH} ../../drop-in/failed/${DROP_ID}
        echo "✓ Moved to failed queue"

# Notifications
notifications:
  on_success:
    - type: log
      message: "Pipeline succeeded for ${DROP_ID}"
  
  on_failure:
    - type: log
      message: "Pipeline failed for ${DROP_ID}: ${ERROR_MESSAGE}"
    
  on_timeout:
    - type: log
      message: "Pipeline timeout for ${DROP_ID}"

# Automation gates
gates:
  # Pre-build gate
  - name: confidence_check
    stage: before_build
    condition: confidence >= 0.80
    failure_action: abort
  
  # Pre-deploy gate
  - name: quality_gate
    stage: before_deploy
    conditions:
      - test_pass_rate >= 0.95
      - build_success == true
      - security_issues == 0
    failure_action: manual_review
  
  # Pre-merge gate
  - name: merge_gate
    stage: before_auto_merge
    conditions:
      - confidence >= 0.98
      - all_tests_passed == true
      - no_security_issues == true
      - code_review_approved == true
    failure_action: create_pr_for_review

# Resource limits
limits:
  max_concurrent_pipelines: 4
  max_pipeline_duration_minutes: 120
  max_retry_attempts: 2
  artifact_retention_days: 30

# Integration settings
integrations:
  crc:
    enabled: true
    ready_queue_path: crc/drop-in/ready
    archive_after_success: true
    cleanup_after_failure: false
  
  git:
    enabled: true
    auto_commit: true
    commit_message_template: "[CRC] Automated integration: ${DROP_ID}"
  
  monitoring:
    enabled: true
    metrics_endpoint: http://localhost:9090/metrics
